# SSO系统流程梳理

### SSO单点登录流程

通过在网上查找资料，找到一张算是比较全且容易理解的流程图，如下：

<img src="https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png">

流程大致如下：

1. **浏览器**发送请求到**子系统1**，请求其网络资源   (浏览器 -> 子系统1)  
2. **子系统1**内部验证当前用户是否已登录 (子系统1内部方法，实际上是SSO Client的职责，检查其是否有对应的局部会话)
3. 经**子系统1**验证验证未登录，**子系统1**带上子系统1的地址将请求重定向到**SSO认证系统**   (子系统1 -> SSO)
4. **SSO认证系统**处理请求，对当前用户是否已登录进行验证。如果未登录将带上子系统1的地址作为参数让**浏览器**跳转到统一登录页面   (SSO -> 浏览器)
5. 用户从**浏览器**输入登录信息后，直接请求到**SSO认证系统**进行登录   (浏览器 -> SSO)
6. **SSO认证系统**收到登录请求后
   1. 首先进行登录信息验证   (LDAP服务端实现)
   2. 创建全局会话   (说明用户在SSO登录成功)
   3. 创建授权令牌   (用户有访问子系统1的资格，jwt实现？)
   4. 请求参数地址(子系统1的地址)并携带令牌请求子系统1   (SSO -> 子系统1，由SSO Server提供)
7. **子系统1**收到令牌后带上令牌和子系统1的地址请求**SSO认证系统**校验令牌   (子系统1 -> SSO)
8. **SSO认证系统**收到令牌验证请求后
   1. 验证令牌有效   (防止有人伪造令牌)
   2. 将子系统1的地址注册(保存)起来   (现在用户拥有了访问子系统1的权利)
   3. 返回**子系统1**令牌有效的信息   (SSO -> 子系统1)
9. **子系统1**收到令牌有效的消息，立即创建局部会话   (此时用户就可以去访问子系统1了)，并返回给浏览器登录成功显示对应页面
10. 用户希望访问其他可信任的应用，例如**子系统2**   (浏览器 -> 子系统2)
11. **子系统2**收到访问请求，内部验证用户是否已登录   (这里不是验证SSO是否登录，而是验证用户是否登录子系统2，同步骤2)
12. **子系统2**验证用户并没有登录子系统2，则带着子系统2的地址作为参数请求**SSO认证系统**进行验证   (子系统2 -> SSO)
13. **SSO认证系统**对当前用户进行验证，发现用户在SSO已经登录(全局会话中取得信息)，则创建授权令牌并带上令牌去访问子系统2的地址   (SSO -> 子系统2)
14. **子系统2**拿着令牌和子系统2的地址再次去请求**SSO认证系统**来检验刚刚拿到的令牌   (子系统2 -> SSO)
15. **SSO认证系统**验证令牌的合法性，如果合法则再次将子系统2的地址进行注册(保存)，并返回令牌有效的信息给子系统2   (SSO -> 子系统2)
16. **子系统2**收到令牌有效的信息，立即创建局部会话，同时返回给浏览器用户访问的资源



从用户的角度看1-4步是第一个阶段，包含了用户想要请求子系统1的某资源，然而没有登录，所以被强制到登录页面登录。且步骤1、2、3应该是同一个方法处理，`此方法应该是一个拦截器，在访问子系统的接口前进行拦截，判断登录`，这个方法应该由SSO Client提供；步骤4则是应该由SSO Server提供，实现方法与前面的方法类似。   (访问子系统1 -> 统一登录页面)

5-9步是第二个阶段，包含了用户输入登录信息请求登录到登录成功跳到对应页面的过程。具体包括了`登录信息验证`、`令牌验证`、`全局会话和局部会话创建`和`系统地址注册`等。至此用户已经可以自由的访问他自己拥有的在子系统1的资源，并且在SSO认证中心也已经有他登录成功的信息。   (登录 -> 登录成功)

10-16步是在用户已经在SSO登录的情况下去访问其他可信任应用的情况。大体过程与访问子系统1时有相似的地方，而又由于用户已经在SSO登录，则又有些步骤被省略。

### SSO单点注销流程

![单点注销流程图](https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155243068-1378377736.png)

流程大致如下：

1. **浏览器**发送注销请求到**子系统1**(这里假设子系统1)，这里的注销请求应该是注销局部会话也就是注销用户与单个子系统的会话   (浏览器 -> 某一子系统)
2. **子系统1**取出令牌(此令牌为子系统与SSO认证中心的令牌)，并携带此令牌发送注销请求到**SSO认证中心**   (子系统1 -> SSO，SSO Client提供)
3. **SSO认证中心**收到注销请求后
   1. 首先校验令牌的合法性   (防止他人伪造令牌)
   2. 销毁全局会话   (用户注销在SSO的登录)
   3. 取出所有此用户注册的系统地址，并逐个发送请求注销与此用户相关的局部会话   (SSO -> 各个子系统)
   4. 返回给浏览器统一登录页面   (SSO -> 浏览器)

全局会话与局部会话的关系

- 局部会话存在，全局会话一定存在
- 全局会话存在，局部会话不一定存在
- 全局会话不存在，局部会话一定不存在
- 局部会话不存在，全局会话不一定不存在
- 局部会话创建后用户访问子系统不再通过SSO 服务端(因为第一步验证已登录子系统成功)

### 部署图

![部署图](https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155244646-2067469767.png)

如上图：

- SSO Client客户端必须与现有应用程序(系统)集成，来进行单点登录的判断
- SSO Server将单独部署在一台服务器上为客户端提供服务
- SSO客户端与服务端之间使用HTTPClient通信

### 功能点梳理

##### SSO Client客户端

- 某子系统**验证用户是否已登录**(是否有局部会话)
- 存储SSO服务端发来的令牌(接收并存储令牌)
- 根据SSO服务端传回的令牌**发送令牌校验请求到SSO服务端**，参数为令牌+(本)子系统地址(校验令牌合法性)
- 收到SSO服务端传来的令牌有效消息后，**创建局部会话**，给用户一个访问本系统的令牌(创建局部会话)
- 接收来自浏览器的注销请求，取出令牌，根据令牌**发送给SSO服务端注销全局会话的请求**(发送注销会话请求)
- **注销局部会话的功能**(自我注销局部会话)

##### SSO Server服务端

- **验证用户是否登录**(是否登录SSO 服务端)
- **执行登录**(验证登录信息、创建全局会话和创建授权令牌 [子系统与SSO服务端之间])
- **发送令牌**(发送令牌给子系统)
- **校验令牌**(校验令牌和注册系统地址)
- **注销全局会话**(验证令牌 [子系统与SSO服务端之间]、注销全局会话、注销各子系统的局部会话和跳转到统一登录页面)